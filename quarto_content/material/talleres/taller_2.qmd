# Python en Ciencia

 **Objetivos del cap铆tulo**

- Comprender el uso de Python en la ciencia tradicional.
- Aplicar Python en simulaciones f铆sicas y an谩lisis estad铆sticos.
- Desarrollar habilidades pr谩cticas para resolver problemas cient铆ficos.
- Utilizar `Quarto-Pyodide` para ejecutar y experimentar con el c贸digo en el navegador.


# 1.  F铆sica

## Simulaci贸n de Movimiento

En este ejercicio, vamos a simular el movimiento de un objeto bajo la influencia de la gravedad y visualizar la trayectoria usando la biblioteca `matplotlib`. Este ejercicio es excelente para practicar el uso de bibliotecas de visualizaci贸n y operaciones matem谩ticas en Python.

### Contexto

La simulaci贸n de movimientos es una aplicaci贸n com煤n en f铆sica y matem谩ticas. En este ejercicio, simularemos la trayectoria de un proyectil lanzado con una velocidad inicial y un 谩ngulo de lanzamiento espec铆ficos. Usaremos las ecuaciones del movimiento para calcular la posici贸n del proyectil en diferentes momentos y visualizaremos la trayectoria usando `matplotlib`.

### Objetivos del Ejercicio

::: {.callout-tip collapse="false" title="Desaf铆o:"}
El objetivo de este ejercicio es escribir una funci贸n en Python que simule el movimiento de un proyectil bajo la influencia de la gravedad, visualizando la trayectoria con `matplotlib`.
:::

1. **Definir los par谩metros de la simulaci贸n**: Establecer valores para la gravedad, el tiempo, la velocidad inicial y el 谩ngulo de lanzamiento.
2. **Calcular la trayectoria del proyectil**: Usar las ecuaciones del movimiento para determinar las posiciones `x` y `y` del proyectil en funci贸n del tiempo.
3. **Visualizar la trayectoria**: Crear una gr谩fica que muestre la trayectoria del proyectil, a帽adiendo efectos visuales para mejorar la presentaci贸n.
4. **Probar la simulaci贸n**: Ajustar los par谩metros para ver c贸mo afectan la trayectoria del proyectil.

### C贸digo para la Simulaci贸n de Movimiento

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Wedge

# Par谩metros de la simulaci贸n
g = 9.8  # aceleraci贸n debido a la gravedad (m/s^2)
t = np.linspace(0, 5, num=100)  # tiempo (s)
v0 = 20  # velocidad inicial (m/s)
theta = np.radians(45)  # 谩ngulo de lanzamiento (grados)

# Componentes de la velocidad inicial
vx = v0 * np.cos(theta)
vy = v0 * np.sin(theta)

# Trayectoria
x = vx * t
y = vy * t - 0.5 * g * t**2

# Punto m谩s alto
max_height_index = np.argmax(y)
max_height_x = x[max_height_index]
max_height_y = y[max_height_index]

# Crear la figura y los ejes
fig, ax = plt.subplots(figsize=(11, 7))
ax.plot(x, y, label='Trayectoria', color='blue', lw=2)

# Agregar un color degradado
for i in range(len(x)-1):
    ax.plot(x[i:i+2], y[i:i+2], color=plt.cm.viridis(i / len(x)))

# Anotar el punto m谩s alto
ax.plot(max_height_x, max_height_y, 'ro')  # punto m谩s alto en rojo
ax.annotate(f'Punto m谩s alto\n({max_height_x:.2f}, {max_height_y:.2f}) m',
            xy=(max_height_x, max_height_y), xytext=(max_height_x+5, max_height_y+5),
            arrowprops=dict(facecolor='black', shrink=0.05),
            fontsize=12, color='red', fontweight='bold')

# Agregar un fondo personalizado
ax.set_facecolor('#f0f0f0')
fig.patch.set_facecolor('#e0e0e0')

# A帽adir el sol y el suelo
sun_center = (max(x) + 10, max(y) + 10)
sun_radius = 3

# Dibujar el c铆rculo central del sol
sun = Circle(sun_center, sun_radius, color='yellow', alpha=0.8, zorder=10)
ax.add_patch(sun)

# Dibujar los rayos del sol
for angle in np.linspace(0, 360, 12, endpoint=False):
    wedge = Wedge(sun_center, sun_radius + 2, angle, angle + 15, color='gold', alpha=0.8, zorder=9)
    ax.add_patch(wedge)

ax.fill_between(x, 0, -10, color='green', alpha=0.5)

# Configurar la gr谩fica
ax.set_title('Trayectoria de un proyectil', fontsize=16, fontweight='bold')
ax.set_xlabel('Distancia horizontal (m)', fontsize=14)
ax.set_ylabel('Altura (m)', fontsize=14)
ax.set_ylim(bottom=0)
ax.legend()

# Mostrar la gr谩fica
plt.show()
```

### Explicaci贸n del C贸digo

Este c贸digo define la simulaci贸n de movimiento de un proyectil y realiza lo siguiente:

1. **Par谩metros de Entrada**:
    - `g`: Aceleraci贸n debido a la gravedad (m/s虏).
    - `t`: Tiempo en segundos, generando 100 puntos entre 0 y 5 segundos.
    - `v0`: Velocidad inicial del proyectil (m/s).
    - `theta`: ngulo de lanzamiento convertido a radianes.

2. **Componentes de la Velocidad Inicial**:
    - `vx`: Componente horizontal de la velocidad inicial.
    - `vy`: Componente vertical de la velocidad inicial.

3. **Trayectoria**:
    - `x`: Posici贸n horizontal en funci贸n del tiempo.
    - `y`: Posici贸n vertical en funci贸n del tiempo considerando la gravedad.

4. **Punto M谩s Alto**:
    - Calcula y anota el punto m谩s alto de la trayectoria del proyectil.

5. **Visualizaci贸n**:
    - Configura la visualizaci贸n de la trayectoria usando `matplotlib`, a帽adiendo efectos visuales como un color degradado, un fondo personalizado, y un sol con rayos.

### Ejemplo de Uso

El c贸digo de ejemplo muestra c贸mo usar los par谩metros definidos para simular la trayectoria de un proyectil con una velocidad inicial de 20 m/s y un 谩ngulo de lanzamiento de 45 grados.

### Prueba y Modificaci贸n

Para hacer el ejemplo m谩s entretenido, los estudiantes pueden cambiar los siguientes par谩metros y observar c贸mo afectan la trayectoria del proyectil:

1. **Velocidad Inicial (`v0`)**:
    - Cambiar `v0` a diferentes valores como 10, 30 o 50 m/s para ver c贸mo la velocidad inicial afecta la distancia y altura m谩xima alcanzada.
    ```{pyodide-python}
    v0 = 30  # Cambiar a diferentes valores
    ```

2. **ngulo de Lanzamiento (`theta`)**:
    - Cambiar `theta` a diferentes 谩ngulos como 30, 60 o 75 grados para ver c贸mo el 谩ngulo de lanzamiento afecta la trayectoria.
    ```{pyodide-python}
    theta = np.radians(60)  # Cambiar a diferentes valores
    ```

3. **Tiempo (`t`)**:
    - Cambiar el rango de tiempo y la cantidad de puntos en el tiempo para observar trayectorias m谩s largas o m谩s cortas.
    ```{pyodide-python}
    t = np.linspace(0, 10, num=200)  # Cambiar el rango de tiempo
    ```

Estos cambios permiten a los estudiantes experimentar con diferentes escenarios y entender mejor c贸mo las variables iniciales afectan el movimiento de un proyectil, haciendo el ejercicio m谩s interactivo y entretenido.


## Simulaci贸n de Movimiento Arm贸nico Simple

En este ejercicio, vamos a simular el movimiento de un oscilador arm贸nico simple y visualizar la posici贸n del oscilador en funci贸n del tiempo usando la biblioteca `matplotlib`. Este ejercicio es excelente para practicar el uso de bibliotecas de visualizaci贸n y operaciones matem谩ticas en Python.

### Contexto

El movimiento arm贸nico simple es un tipo de oscilaci贸n que se describe con la ecuaci贸n diferencial de un resorte ideal sin fricci贸n. La posici贸n del oscilador en funci贸n del tiempo se puede describir usando la funci贸n coseno. Este tipo de movimiento es com煤n en sistemas f铆sicos como p茅ndulos y resortes.

### Objetivos del Ejercicio

::: {.callout-tip collapse="false" title="Desaf铆o:"}
El objetivo de este ejercicio es escribir una funci贸n en Python que simule el movimiento de un oscilador arm贸nico simple y visualice la posici贸n del oscilador en funci贸n del tiempo usando `matplotlib`.
:::

1. **Importar bibliotecas**: Usaremos `numpy` para las operaciones matem谩ticas y `matplotlib` para la visualizaci贸n.
2. **Definir par谩metros del oscilador**: Estableceremos los par谩metros como la masa del oscilador, la constante del resorte, la frecuencia angular y la amplitud.
3. **Calcular la posici贸n**: Usaremos la f贸rmula del movimiento arm贸nico simple para calcular la posici贸n del oscilador en diferentes momentos.
4. **Visualizar la posici贸n**: Crearemos una gr谩fica de la posici贸n del oscilador en funci贸n del tiempo utilizando `matplotlib`.

### C贸digo para la Simulaci贸n de Movimiento Arm贸nico Simple

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

# Par谩metros del oscilador
m = 5.0  # masa (kg)
k = 10.0  # constante de resorte (N/m)
omega = np.sqrt(k / m)  # frecuencia angular (rad/s)
A = 25  # amplitud (m)
t = np.linspace(0, 10, num=500)  # tiempo (s)

# Posici贸n como funci贸n del tiempo
x = A * np.cos(omega * t)

# Crear la figura y los ejes
fig, ax = plt.subplots(figsize=(11, 6))

# A帽adir un color degradado a la curva
colors = plt.cm.viridis(np.linspace(0, 1, len(t)))
for i in range(len(t)-1):
    ax.plot(t[i:i+2], x[i:i+2], color=colors[i])

# Anotar puntos de inter茅s
ax.annotate('Amplitud m谩xima', xy=(0, A), xytext=(1, A + 5),
            arrowprops=dict(facecolor='black', shrink=0.05),
            fontsize=12, color='red', fontweight='bold')

# Configurar el fondo y estilo de la gr谩fica
ax.set_facecolor('#f0f0f0')
fig.patch.set_facecolor('#e0e0e0')

# A帽adir elementos visuales adicionales (como un resorte estilizado)
spring_x = np.linspace(0, t[-1], 1000)
spring_y = A * np.cos(omega * spring_x) / 5
ax.plot(spring_x, spring_y, color='gray', linestyle='--', lw=0.5, alpha=0.7)

# Configurar la gr谩fica
ax.set_title('Movimiento Arm贸nico Simple', fontsize=16, fontweight='bold')
ax.set_xlabel('Tiempo (s)', fontsize=14)
ax.set_ylabel('Posici贸n (m)', fontsize=14)
ax.grid(True)

# Fijar los l铆mites de los ejes
ax.set_xlim(0, 10)
ax.set_ylim(-100, 100)

# Mostrar la gr谩fica
plt.show()
```

### Explicaci贸n del C贸digo

Este c贸digo define la simulaci贸n del movimiento de un oscilador arm贸nico simple y realiza lo siguiente:

1. **Par谩metros de Entrada**:
    - `m`: Masa del oscilador (kg).
    - `k`: Constante del resorte (N/m).
    - `omega`: Frecuencia angular (rad/s), calculada a partir de `m` y `k`.
    - `A`: Amplitud del movimiento (m).
    - `t`: Tiempo en segundos, generando 500 puntos entre 0 y 10 segundos.

2. **Posici贸n como Funci贸n del Tiempo**:
    - `x`: Posici贸n del oscilador en funci贸n del tiempo usando la f贸rmula del movimiento arm贸nico simple \( x = A \cos(\omega t) \).

3. **Visualizaci贸n**:
    - Configura la visualizaci贸n de la posici贸n del oscilador usando `matplotlib`, a帽adiendo efectos visuales como un color degradado y un fondo personalizado.
    - Anota puntos de inter茅s como la amplitud m谩xima.

### Ejemplo de Uso

El c贸digo de ejemplo muestra c贸mo usar los par谩metros definidos para simular la posici贸n de un oscilador con una masa de 5 kg, una constante del resorte de 10 N/m, una amplitud de 25 m y una frecuencia angular calculada.

### Prueba y Modificaci贸n

Para hacer el ejemplo m谩s entretenido, los estudiantes pueden cambiar los siguientes par谩metros y observar c贸mo afectan la posici贸n del oscilador:

1. **Masa del Oscilador (`m`)**:
    - Cambiar `m` a diferentes valores como 2.0, 8.0 o 10.0 kg para ver c贸mo la masa afecta la frecuencia angular y el movimiento.
    ```{pyodide-python}
    m = 2.0  # Cambiar a diferentes valores
    omega = np.sqrt(k / m)
    ```

2. **Constante del Resorte (`k`)**:
    - Cambiar `k` a diferentes valores como 5.0, 20.0 o 50.0 N/m para ver c贸mo la constante del resorte afecta la frecuencia angular y el movimiento.
    ```{pyodide-python}
    k = 20.0  # Cambiar a diferentes valores
    omega = np.sqrt(k / m)
    ```

3. **Amplitud (`A`)**:
    - Cambiar `A` a diferentes valores como 10, 50 o 75 m para ver c贸mo la amplitud afecta la posici贸n del oscilador.
    ```{pyodide-python}
    A = 50  # Cambiar a diferentes valores
    ```

4. **Tiempo (`t`)**:
    - Cambiar el rango de tiempo y la cantidad de puntos en el tiempo para observar oscilaciones m谩s largas o m谩s cortas.
    ```{pyodide-python}
    t = np.linspace(0, 20, num=1000)  # Cambiar el rango de tiempo
    ```

Estos cambios permiten a los estudiantes experimentar con diferentes escenarios y entender mejor c贸mo las variables iniciales afectan el movimiento del oscilador arm贸nico simple, haciendo el ejercicio m谩s interactivo y entretenido.



# 2.  Estad铆stica y Probabilidad

## Lanzamiento de Moneda

En este ejercicio, vamos a simular el lanzamiento de una moneda y calcular la probabilidad de obtener cara o cruz. Este ejercicio es excelente para practicar el uso de arrays y funciones estad铆sticas en Python con la biblioteca `numpy`.

### Contexto

El lanzamiento de una moneda es un experimento cl谩sico en probabilidad. En cada lanzamiento, hay una probabilidad del 50% de obtener cara y una probabilidad del 50% de obtener cruz. Simulando m煤ltiples lanzamientos, podemos estimar las probabilidades experimentales y compararlas con las probabilidades te贸ricas.

### Objetivos del Ejercicio

::: {.callout-tip collapse="false" title="Desaf铆o:"}
El objetivo de este ejercicio es escribir un programa en Python que simule el lanzamiento de una moneda, cuente las ocurrencias de cara y cruz, y calcule las probabilidades de cada resultado.
:::

1. **Importar bibliotecas**: Usaremos `numpy` para generar los lanzamientos de la moneda y calcular las frecuencias.
2. **Simular lanzamientos**: Generaremos un n煤mero espec铆fico de lanzamientos de la moneda utilizando `numpy.random.choice`.
3. **Calcular frecuencias**: Contaremos las ocurrencias de cara y cruz.
4. **Calcular probabilidades**: Calcularemos las probabilidades de obtener cara y cruz basadas en las frecuencias.
5. **Mostrar los resultados**: Imprimiremos las frecuencias y probabilidades calculadas.

### C贸digo para el Lanzamiento de Moneda

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

# N煤mero de lanzamientos
n_lanzamientos = 100

# Simular lanzamientos de una moneda
lanzamientos = np.random.choice(['Cara', 'Cruz'], n_lanzamientos)

# Calcular la frecuencia de cada resultado
caras = np.sum(lanzamientos == 'Cara')
cruces = np.sum(lanzamientos == 'Cruz')

# Calcular las probabilidades
prob_cara = caras / n_lanzamientos
prob_cruz = cruces / n_lanzamientos

print(f"Caras: {caras}, Cruces: {cruces}")
print(f"Probabilidad de Cara: {prob_cara:.2f}")
print(f"Probabilidad de Cruz: {prob_cruz:.2f}")

# Crear un gr谩fico de barras para la frecuencia de cada resultado
plt.figure(figsize=(11, 5))

plt.subplot(1, 2, 1)
plt.bar(['Caras', 'Cruces'], [caras, cruces], color=['lightblue', 'cyan'], edgecolor='black')
plt.title('Frecuencia de Caras y Cruces')
plt.ylabel('Frecuencia')
plt.ylim(0, n_lanzamientos)
plt.grid()

# Calcular probabilidades acumuladas
prob_cara_acumulada = np.cumsum(lanzamientos == 'Cara') / np.arange(1, n_lanzamientos + 1)
prob_cruz_acumulada = np.cumsum(lanzamientos == 'Cruz') / np.arange(1, n_lanzamientos + 1)

# Crear un gr谩fico de l铆neas para las probabilidades acumuladas
plt.subplot(1, 2, 2)
plt.plot(prob_cara_acumulada, label='Probabilidad de Cara', color='lightblue')
plt.plot(prob_cruz_acumulada, label='Probabilidad de Cruz', color='cyan')
plt.title('Probabilidades Acumuladas')
plt.xlabel('N煤mero de Lanzamientos')
plt.ylabel('Probabilidad')
plt.legend()
plt.ylim(0, 1)
plt.grid()

# Ajustar el dise帽o de los gr谩ficos
plt.subplots_adjust(wspace=0.3)
plt.show()
```

### Explicaci贸n del C贸digo

Este c贸digo simula el lanzamiento de una moneda y realiza lo siguiente:

1. **N煤mero de Lanzamientos**:
    - `n_lanzamientos`: Define el n煤mero de lanzamientos a simular.

2. **Simulaci贸n de Lanzamientos**:
    - `lanzamientos`: Utiliza `np.random.choice` para generar una secuencia de 'Cara' y 'Cruz'.

3. **C谩lculo de Frecuencias**:
    - `caras`: Cuenta el n煤mero de veces que aparece 'Cara'.
    - `cruces`: Cuenta el n煤mero de veces que aparece 'Cruz'.

4. **C谩lculo de Probabilidades**:
    - `prob_cara`: Calcula la probabilidad de obtener 'Cara'.
    - `prob_cruz`: Calcula la probabilidad de obtener 'Cruz'.

5. **Visualizaci贸n**:
    - Gr谩fico de barras para mostrar la frecuencia de cada resultado.
    - Gr谩fico de l铆neas para mostrar las probabilidades acumuladas de cada resultado a lo largo de los lanzamientos.

### Ejemplo de Uso

El c贸digo de ejemplo muestra c贸mo simular 100 lanzamientos de una moneda y calcular las probabilidades de obtener cara o cruz. Los resultados se muestran en gr谩ficos para facilitar la visualizaci贸n.

### Prueba y Modificaci贸n

Para hacer el ejemplo m谩s entretenido, los estudiantes pueden cambiar los siguientes par谩metros y observar c贸mo afectan los resultados:

1. **N煤mero de Lanzamientos (`n_lanzamientos`)**:
    - Cambiar `n_lanzamientos` a diferentes valores como 200, 500 o 1000 para ver c贸mo el n煤mero de lanzamientos afecta la precisi贸n de las probabilidades calculadas.
    ```{pyodide-python}
    n_lanzamientos = 500  # Cambiar a diferentes valores
    ```

Estos cambios permiten a los estudiantes experimentar con diferentes escenarios y entender mejor c贸mo las variables iniciales afectan los resultados de la simulaci贸n, haciendo el ejercicio m谩s interactivo y entretenido.


## Lanzamiento de Dados

En este ejercicio, vamos a simular el lanzamiento de dos dados y calcular la frecuencia de cada suma posible. Este ejercicio es excelente para practicar el uso de arrays, funciones estad铆sticas y diccionarios en Python con la biblioteca `numpy`.

### Contexto

El lanzamiento de dos dados es un experimento cl谩sico en probabilidad. Cada dado tiene seis caras, numeradas del 1 al 6. Cuando se lanzan dos dados, las sumas posibles de los n煤meros en las caras superiores van desde 2 hasta 12. Simulando m煤ltiples lanzamientos, podemos calcular la frecuencia de cada suma y analizar la distribuci贸n de los resultados.

### Objetivos del Ejercicio

::: {.callout-tip collapse="false" title="Desaf铆o:"}
El objetivo de este ejercicio es escribir un programa en Python que simule el lanzamiento de dos dados, calcule la frecuencia de cada suma posible y muestre los resultados.
:::

1. **Importar bibliotecas**: Usaremos `numpy` para generar los lanzamientos de los dados y calcular las frecuencias.
2. **Simular lanzamientos**: Generaremos un n煤mero espec铆fico de lanzamientos de dos dados utilizando `numpy.random.randint`.
3. **Calcular sumas**: Calcularemos las sumas de los resultados de los dos dados.
4. **Calcular frecuencias**: Contaremos las ocurrencias de cada suma posible usando un diccionario.
5. **Mostrar los resultados**: Imprimiremos la frecuencia de cada suma calculada y visualizaremos los resultados con gr谩ficos.

### C贸digo para el Lanzamiento de Dados

```{pyodide-python}
import numpy as np
import matplotlib.pyplot as plt

# N煤mero de lanzamientos
n_lanzamientos = 100

# Simular lanzamientos de dos dados
np.random.seed(42)  # para reproducibilidad
dado1 = np.random.randint(1, 7, n_lanzamientos)
dado2 = np.random.randint(1, 7, n_lanzamientos)
sumas = dado1 + dado2

# Calcular la frecuencia de cada suma
frecuencias = {suma: np.sum(sumas == suma) for suma in range(2, 13)}

# Mostrar las frecuencias en la consola
print("Frecuencia de cada suma:")
for suma, frecuencia in frecuencias.items():
    print(f"Suma {suma}: {frecuencia}")

# Crear un gr谩fico de barras para las frecuencias
fig, ax = plt.subplots(figsize=(11, 6))

sums = list(frecuencias.keys())
counts = list(frecuencias.values())

bars = ax.bar(sums, counts, color=plt.cm.viridis(np.linspace(0, 1, len(sums))))

# Crear un histograma para la distribuci贸n de las sumas
fig, ax3 = plt.subplots(figsize=(11, 6))
ax3.hist(sumas, bins=np.arange(2, 14) - 0.5, edgecolor='black', color='lightblue', alpha=0.7)
ax3.set_title('Distribuci贸n de las Sumas de Dos Dados', fontsize=16, fontweight='bold')
ax3.set_xlabel('Suma', fontsize=14)
ax3.set_ylabel('Frecuencia', fontsize=14)
ax3.set_xticks(sums)
ax3.set_xticklabels(sums)
ax3.set_xlim(1.5, 12.5)
ax3.grid(True)

# Mostrar los gr谩ficos
plt.show()
```

### Explicaci贸n del C贸digo

Este c贸digo simula el lanzamiento de dos dados y realiza lo siguiente:

1. **N煤mero de Lanzamientos**:
    - `n_lanzamientos`: Define el n煤mero de lanzamientos a simular.

2. **Simulaci贸n de Lanzamientos**:
    - `dado1` y `dado2`: Utiliza `np.random.randint` para generar los resultados de los lanzamientos de los dos dados.
    - `sumas`: Calcula las sumas de los resultados de los dos dados.

3. **C谩lculo de Frecuencias**:
    - `frecuencias`: Cuenta las ocurrencias de cada suma posible usando un diccionario.

4. **Visualizaci贸n**:
    - Gr谩fico de barras para mostrar la frecuencia de cada suma.
    - Gr谩fico de l铆neas para mostrar la frecuencia acumulada de las sumas.
    - Histograma para mostrar la distribuci贸n de las sumas.

### Ejemplo de Uso

El c贸digo de ejemplo muestra c贸mo simular 100 lanzamientos de dos dados y calcular la frecuencia de cada suma posible. Los resultados se muestran en gr谩ficos para facilitar la visualizaci贸n.

### Prueba y Modificaci贸n

Para hacer el ejemplo m谩s entretenido, los estudiantes pueden cambiar los siguientes par谩metros y observar c贸mo afectan los resultados:

1. **N煤mero de Lanzamientos (`n_lanzamientos`)**:
    - Cambiar `n_lanzamientos` a diferentes valores como 200, 500 o 1000 para ver c贸mo el n煤mero de lanzamientos afecta la precisi贸n de las frecuencias calculadas.
    ```{pyodide-python}
    n_lanzamientos = 500  # Cambiar a diferentes valores
    ```

Estos cambios permiten a los estudiantes experimentar con diferentes escenarios y entender mejor c贸mo las variables iniciales afectan los resultados de la simulaci贸n, haciendo el ejercicio m谩s interactivo y entretenido.